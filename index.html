<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>OPENAI GPU LIMIT TEST</title>
<style>
html,body{margin:0;overflow:hidden;background:black}
#t{position:fixed;top:10px;left:10px;color:#0f0;font-family:monospace}
</style>
</head>
<body>
<div id="t">WEBGPU â€“ EXTREME MODE</div>

<script type="module">
if(!navigator.gpu){
  document.body.innerHTML="WebGPU not supported";
  throw "No WebGPU";
}

const adapter = await navigator.gpu.requestAdapter({
  powerPreference: "high-performance"
});
const device = await adapter.requestDevice();

const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
canvas.width = innerWidth;
canvas.height = innerHeight;

const ctx = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();
ctx.configure({ device, format });

// ---------- VRAM FLOOD ----------
const TEX_SIZE = 8192; // ðŸ”¥ VRAM EATER
const textures = [];
for(let i=0;i<6;i++){
  textures.push(device.createTexture({
    size:[TEX_SIZE,TEX_SIZE,1],
    format:"rgba32float",
    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
  }));
}

// ---------- COMPUTE SHADER ----------
const compute = device.createComputePipeline({
  layout:"auto",
  compute:{
    module:device.createShaderModule({
      code:`
@group(0) @binding(0) var img : texture_storage_2d<rgba32float, write>;

@compute @workgroup_size(16,16)
fn main(@builtin(global_invocation_id) id:vec3<u32>){
  let uv = vec2<f32>(id.xy)/vec2<f32>(${TEX_SIZE}.0);
  var c = vec4<f32>(0.0);
  for(var i=0;i<200;i++){   // ðŸ”¥ CORE MELTER
    c += vec4<f32>(
      sin(uv.x*float(i)),
      cos(uv.y*float(i)),
      sin(float(i)),
      1.0
    );
  }
  textureStore(img,vec2<i32>(id.xy),c);
}`
    }),
    entryPoint:"main"
  }
});

// ---------- RENDER PIPELINE ----------
const render = device.createRenderPipeline({
  layout:"auto",
  vertex:{
    module:device.createShaderModule({
      code:`@vertex fn main(@builtin(vertex_index) i:u32)
      -> @builtin(position) vec4<f32>{
        var p = array<vec2<f32>,3>(
          vec2<f32>(-1,-1),
          vec2<f32>( 3,-1),
          vec2<f32>(-1, 3)
        );
        return vec4<f32>(p[i],0,1);
      }`
    }),
    entryPoint:"main"
  },
  fragment:{
    module:device.createShaderModule({
      code:`
@group(0) @binding(0) var tex : texture_2d<f32>;
@fragment fn main(@builtin(position) p:vec4<f32>)
-> @location(0) vec4<f32>{
  let uv = p.xy/vec2<f32>(${innerWidth}.0,${innerHeight}.0);
  var col = vec3<f32>(0.0);
  for(var i=0;i<120;i++){ // ðŸ”¥ FRAGMENT HELL
    col += textureSampleLevel(tex,sampler(),uv,0.0).rgb;
  }
  return vec4<f32>(col/120.0,1.0);
}`
    }),
    entryPoint:"main",
    targets:[{format}]
  }
});

const sampler = device.createSampler();

// ---------- LOOP ----------
function frame(){
  const enc = device.createCommandEncoder();

  // Compute Pass
  for(const t of textures){
    const pass = enc.beginComputePass();
    pass.setPipeline(compute);
    pass.setBindGroup(0,device.createBindGroup({
      layout:compute.getBindGroupLayout(0),
      entries:[{binding:0,resource:t.createView()}]
    }));
    pass.dispatchWorkgroups(TEX_SIZE/16,TEX_SIZE/16);
    pass.end();
  }

  // Render Pass
  const pass = enc.beginRenderPass({
    colorAttachments:[{
      view:ctx.getCurrentTexture().createView(),
      loadOp:"clear",
      storeOp:"store"
    }]
  });
  pass.setPipeline(render);
  pass.setBindGroup(0,device.createBindGroup({
    layout:render.getBindGroupLayout(0),
    entries:[
      {binding:0,resource:textures[0].createView()},
      {binding:1,resource:sampler}
    ]
  }));
  pass.draw(3);
  pass.end();

  device.queue.submit([enc.finish()]);
  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
